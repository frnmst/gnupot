#!/bin/bash

#
# gnupot
#
# Copyright (C) 2015 frnmst (Franco Masotti) <franco.masotti@live.com>
#                                            <franco.masotti@student.unife.it>
#
# This file is part of GNUpot.
#
# GNUpot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GNUpot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GNUpot.  If not, see <http://www.gnu.org/licenses/>.
#


# Enable automatic export of all variables form now on.
# This avoids putting "export" in front of every variable.
set -a

# Set path.
PATH="$PATH":/usr/bin

# Flock so that script is not executed more than once.
# See man 1 flock (examples section).
[ "${FLOCKER}" != "$0" ] && exec env FLOCKER="$0" flock -en "$0" "$0" "$@" || :

# Load configuration.
if [ -f "gnupot.config" ]; then
	source gnupot.config
fi

# Macros.
# TODO: Add -i <public key> as explicit parameter.
SSHCONNECTCMDARGS="-S "$gnupotSSHMasterSocketPath" \
"$gnupotServerUsername"@"$gnupotServer""

# Open master socket so that further connection will result faster
# (using multiplexing to avoid re-authentication).
SSHMASTERSOCKCMDARGS="-M -o \
ControlPersist="$gnupotSSHMasterSocketTime" \
$SSHCONNECTCMDARGS exit"


# inotifywait command macro: recursive, quiet, listen only to certain events.
INOTIFYWAITCMD="inotifywait -r -q -e modify -e attrib \
-e move -e move_self -e create -e delete -e delete_self"


# General notification function.
function notifyCmd ()
{

	msg="$1"
	ms="$2"


	notify-send -t "$ms" "$msg"

	return 0

}

function syncNotify ()
{

	path="$1"
	dir="$2"
	source="$3"


	notifyCmd "GNUpot syncing $(getRelativePath "$path" \
"$dir") from "$source"" "$gnupotDefaultNotificationTime"

	return 0

}

# Get relative path for local files.
# TODO better.
function getRelativePath ()
{

	fullPath="$1"
	srcDir="$2"
	tmp=""


	# Get relative path of file.
	tmp="${fullPath##"$srcDir"}"
	# Remove heading slash and return value.
	echo "${tmp:1}"

	return 0

}

# Main file syncronization function.
# This is executed inside a critical section.
function syncOperation ()
{

	source="$1"
	path="$2"


	sleep "$gnupotTimeToWaitForOtherChanges"
	syncNotify "$path" "$gnupotLocalDir" "$source"

	if [ "$source" == "client" ]; then
		cd "$gnupotLocalDir"
		git add -A
		git commit -a -m "Commit on $(date "+%s")"
		git push origin master
		cd --
	else
		cd "$gnupotLocalDir"
		git pull origin master
		cd --
	fi

	# OK.
	notifyCmd "Done." "$gnupotDefaultNotificationTime"

	return 0

}

# Kill program if local and/or remote directories do not exist.
function checkDirExistence ()
{

	input="$1"


	if [ "$input" -ne 0 ]; then
		errMsg="Local and/or remote directory does/do not exist."
		echo -en "$errMsg\n"
		notifyCmd "$errMsg" "$gnupotDefaultNotificationTime"
		# THIS IS UGLY BUT SHOULD WORK
		kill -s SIGINT 0
	fi

	return 0

}

function checkServerDirExistence ()
{

	# Check if remote directory exists.
	dirNotExists=$(ssh $SSHCONNECTCMDARGS "if [ ! -d $gnupotRemoteDir ]; \
then echo 1; else echo 0; fi")
	checkDirExistence "$dirNotExists"

	return 0

}

function checkClientDirExistence ()
{

	# Check if local directory exists.
	dirNotExists=$(if [ ! -d "$gnupotLocalDir" ]; \
then echo 1; else echo 0; fi)
	checkDirExistence "$dirNotExists"

	return 0

}

# Server sync thread.
function syncS ()
{

	# return/exit when signal{s} is/are received.
	trap "return 0" SIGINT SIGTERM

	# Open master ssh socket.
	ssh $SSHMASTERSOCKCMDARGS 2>&-

	checkServerDirExistence

	while true; do

		# Listen for changes on server
		path=$(ssh $SSHCONNECTCMDARGS "$INOTIFYWAITCMD" \
"$gnupotRemoteDir" | awk ' { print $1 $3 } ')
		# Open a subshell for critical section.
		(
			# While not acquire lock:
			# while [ ! flock -n 1024 ]; do :; done
			# is the same as the following line:
			flock -x "$FD"
			syncOperation "server" "$path"
		# End critical section.
		) {FD}>>.lockfile
		# Get first valid file descriptor from a bash builtin.

	done

}

# Client sync thread.
function syncC ()
{

	trap "return 0" SIGINT SIGTERM

	checkClientDirExistence

	while true; do

		path=$($INOTIFYWAITCMD --exclude .git "$gnupotLocalDir" \
| awk ' { print $1 $3 } ')
		(
			flock -x "$FD"
			syncOperation "client" "$path"
		) {FD}>>.lockfile

	done

}

# Signal handler function.
function sigHandler ()
{

	echo -en "GNUpot killed\n" 1>&2

	# Kill master ssh socket (this will kill any ssh connection associated
	# with it). Also disable stderr output for this command with "2>&-".
	ssh -O exit -S "$gnupotSSHMasterSocketPath" "$gnupotServer" 2>&- &
	# Kill all the processes of this group.
	kill -s SIGINT 0

	return 0

}

# Clean before exiting.
function clean ()
{

	# Wait for client and server threads before exiting.
	wait "$srvPid" "$cliPid"

	return 0

}

# Main function that runs in background.
function main ()
{

	# Enable signal interpretation to kill all subshells
	trap "sigHandler" SIGINT SIGTERM

	notifyCmd "GNUpot starting..." "$gnupotDefaultNotificationTime"

	# Listen from server and send to client.
	syncS &
	srvPid="$!"
	# Listen from client and send to server.
	syncC &
	cliPid="$!"

	clean

	notifyCmd "GNUpot stopped..." "$gnupotDefaultNotificationTime"

	return 0

}

# Call main function as spawned shell (execute and return control to the
# shell).
main &

exit 0
